"""
Statefully builds OBJ commands, including animations and materials.

Takes in OBJ directives and their parameters and outputs at the end Blender datablocks
"""
import collections
import copy
import itertools
import math
import pathlib
import random
import re
from collections import namedtuple
from dataclasses import dataclass, field
from itertools import islice, tee
from pathlib import Path
from pprint import pprint
from typing import (
    Any,
    Callable,
    Deque,
    Dict,
    Iterator,
    List,
    Mapping,
    Optional,
    Sequence,
    Set,
    Tuple,
    Union,
)

import bmesh
import bpy
from io_xplane2blender.xplane_props import XPlaneManipulatorSettings
from mathutils import Euler, Matrix, Quaternion, Vector

from io_xplane2blender.tests import test_creation_helpers
from io_xplane2blender.tests.test_creation_helpers import (
    AxisAngle,
    DatablockInfo,
    ParentInfo,
)
from io_xplane2blender.xplane_constants import (
    ANIM_TYPE_HIDE,
    ANIM_TYPE_SHOW,
    ANIM_TYPE_TRANSFORM,
    PRECISION_KEYFRAME,
    MANIP_COMMAND,
    MANIP_COMMAND_KNOB,
    MANIP_COMMAND_KNOB2,
    MANIP_COMMAND_SWITCH_UP_DOWN,
    MANIP_COMMAND_SWITCH_UP_DOWN2,
    MANIP_COMMAND_SWITCH_LEFT_RIGHT,
    MANIP_COMMAND_SWITCH_LEFT_RIGHT2,
    MANIP_DRAG_ROTATE,
    MANIP_DRAG_ROTATE_DETENT,
    MANIP_DRAG_XY,
    MANIP_DRAG_AXIS,
    MANIP_DRAG_AXIS_DETENT,
    MANIP_DELTA,
    MANIP_WRAP,
    MANIP_TOGGLE,
    MANIP_AXIS_KNOB,
    MANIP_AXIS_SWITCH_UP_DOWN,
    MANIP_AXIS_SWITCH_LEFT_RIGHT,
    MANIP_NOOP,
    MANIP_PUSH,
    MANIP_RADIO,
    MANIP_COMMAND_AXIS,
    MANIP_DRAG_AXIS_PIX,
    COCKPIT_FEATURE_PANEL,
    COCKPIT_FEATURE_DEVICE,
    LIGHT_PARAM,
    MANIP_CURSOR_HAND
)
from io_xplane2blender.xplane_helpers import (
    ExportableRoot,
    floatToStr,
    is_vector_axis_aligned,
    logger,
    round_vec,
    vec_b_to_x,
    vec_x_to_b,
)

@dataclass
class Attr_light_level:
    v1: float
    v2: float
    path: str

@dataclass
class Attr_manip:
    type: str = ""
    tooltip: str = ""
    cursor: str = MANIP_CURSOR_HAND
    xyz1: Vector = Vector()
    dx: float = 0.0
    dy: float = 0.0
    dz: float = 0.0
    v1: float = 0.0
    v2: float = 0.0
    v1_min: float = 0.0
    v1_max: float = 0.0
    v2_min: float = 0.0
    v2_max: float = 0.0
    v_down: float = 0.0
    v_up: float = 0.0
    v_hold: float = 0.0
    v_on: float = 0.0
    v_off: float = 0.0
    command: str = ""
    positive_command: str = ""
    negative_command: str = ""
    dataref1: str = ""
    dataref2: str = ""
    step: float = 0.0
    click_step: float = 0.0
    hold_step: float = 0.0
    wheel_delta: float = 0.0
    exp: float = 1.0
    # axis_detent_ranges: collection ???
    detents: List[Tuple[float, float,float]] = field(default_factory=list)

@dataclass
class Attr_cockpit_device:
    name: str = ""
    bus: int = ""
    light_channel: int = 0
    auto_adjust: int = 0

@dataclass
class IntermediateDataref:
    """
    Matches xplane_props.XPlaneDataref.

    Made since dataclasses are more flexible then bpy.types.PropertyGroups.
    """

    anim_type: str = ANIM_TYPE_TRANSFORM
    loop: float = 0.0
    path: str = ""
    show_hide_v1: float = 0
    show_hide_v2: float = 0
    location_values: List[float] = field(default_factory=list)
    rotation_values: List[float] = field(default_factory=list)

    def __hash__(self):
        return hash(
            (
                self.anim_type,
                self.loop,
                self.path,
                self.show_hide_v1,
                self.show_hide_v2,
                tuple(self.location_values),
                tuple(self.rotation_values),
            )
        )


@dataclass
class IntermediateAnimation:
    """
    An animation is everything generated by one pair of ANIM_trans/rotate pair (or
    the static version). An IntermediateDatablock may have 0 or more of these.
    """

    # Blender Locations, pair with location_values
    # in xp_dataref
    locations: List[Vector] = field(default_factory=list)

    # Axis of rotations and the degrees of rotation along them.
    # - Will be empty, have 1 Off Axis Axis Angle, or 1 to 3 Axis Aligned Axis (
    # interpreted as a Euler)
    # - Must be paired with rotation_mode to have meaning
    # - Pairs perfectly with rotation_values in xp_dataref
    rotations: Dict[Vector, List[float]] = field(
        default_factory=lambda: collections.defaultdict(list)
    )
    xp_dataref: IntermediateDataref = field(
        default_factory=lambda: IntermediateDataref()
    )

    def apply_animation(self, bl_object: bpy.types.Object):
        """
        Applies any collected animations to a Blender Object
        """

        def recompose_rotation(
            rotation_mode: str, keyframe_idx: int
        ) -> Union[AxisAngle, Euler]:
            """
            Extract rotation at rotation keyframe idx,
            for use in KeyframeInfo.

            Rotations must be either
            - 1 AxisAngle
            - 1 to 3 axis that are all axis aligned
            - 1 to n axis that are not all axis aligned
            """
            if rotation_mode == "AXIS_ANGLE":
                axis, rotations = next(iter(self.rotations.items()))
                return AxisAngle(axis, math.radians(rotations[keyframe_idx]))
            else:

                def axis_to_label(axis):
                    r_axis = tuple(
                        map(lambda c: abs(int(round(c, PRECISION_KEYFRAME))), axis)
                    )
                    return {
                        (1, 0, 0): "X",
                        (0, 1, 0): "Y",
                        (0, 0, 1): "Z",
                    }[r_axis]

                # With this we become immune to any mutations to self.rotations order, but instead rely that
                # rotation_mode is absolutely right
                rotations = {
                    axis_to_label(axis): (axis, degrees)
                    for axis, degrees in self.rotations.items()
                }
                euler_components = {"X": 0, "Y": 0, "Z": 0}
                for axis_label, (axis, degrees) in rotations.items():
                    r_axis = tuple(
                        map(lambda c: bool(round(c, PRECISION_KEYFRAME)), axis)
                    )

                    # Remember, all axis are normalized, so we're okay
                    euler_components[axis_label] = axis[
                        r_axis.index(True)
                    ] * math.radians(degrees[keyframe_idx])

                tot_rot = Euler(euler_components.values(), rotation_mode)
                return tot_rot

        if self.xp_dataref.anim_type == ANIM_TYPE_TRANSFORM:
            keyframe_infos = []
            current_frame = 1
            for value_idx, value in enumerate(self.xp_dataref.location_values):
                keyframe_infos.append(
                    test_creation_helpers.KeyframeInfo(
                        idx=current_frame,
                        dataref_path=self.xp_dataref.path,
                        dataref_value=value,
                        dataref_loop=self.xp_dataref.loop,
                        dataref_anim_type=self.xp_dataref.anim_type,
                        location=self.locations[value_idx] + bl_object.location
                        if self.locations
                        else None,
                    )
                )
                current_frame += 1
            current_frame = 1
            for value_idx, value in enumerate(self.xp_dataref.rotation_values):
                keyframe_infos.append(
                    test_creation_helpers.KeyframeInfo(
                        idx=current_frame,
                        dataref_path=self.xp_dataref.path,
                        dataref_value=value,
                        dataref_loop=self.xp_dataref.loop,
                        dataref_anim_type=self.xp_dataref.anim_type,
                        location=None,
                        rotation=recompose_rotation(bl_object.rotation_mode, value_idx)
                        if self.rotations
                        else None,
                        rotation_mode=bl_object.rotation_mode,
                    )
                )
                current_frame += 1
        else:
            keyframe_infos = [
                test_creation_helpers.KeyframeInfo(
                    idx=1,
                    dataref_path=self.xp_dataref.path,
                    dataref_show_hide_v1=self.xp_dataref.show_hide_v1,
                    dataref_show_hide_v2=self.xp_dataref.show_hide_v2,
                    dataref_anim_type=self.xp_dataref.anim_type,
                )
            ]

        test_creation_helpers.set_animation_data(bl_object, keyframe_infos)
        current_frame = 1

    @property
    def is_animated_location(self) -> bool:
        return self.locations and self.xp_dataref.location_values

    @property
    def is_animated_rotation(self) -> bool:
        return self.rotations and self.xp_dataref.rotation_values

    """
    # Always
    # - You will have one of (type == "TRANSFORM" and (locations xor rotations) or (type == "SHOW"/"HIDE")
    # - locations cannot be "merged" for the same set of values, they are replaced instead, TODO: Is that true? "translations can dance around each other in each 'room'"
    # - All axis in rotations will be unit length
    # - locations and each axis's degrees list must equal the dataref's values list
    def is_valid_prior_optimization(self) -> bool:
        # - rotations will have a length of 0 or 1
        if self.xp_dataref.anim_type == ANIM_TYPE_TRANSFORM:
            exclusive_use = (self.locations and not self.rotations) or (
                not self.locations and self.rotations
            )
            # TODO: Support AngleAxis
            return exclusive_use and is_vector_axis_aligned(next(self.rotations
        else:
            return not self.locations and not self.rotations
    def is_valid_post_optimization(self)-> bool:
        # - rotations dict may have 0-3 entries, See doc for rotations according to rules of being AA or Euler
    """


LODRange = namedtuple("LODRange", ["near", "far"], defaults=[0, 0])


@dataclass
class IntermediateDatablock:

    # You'll want to change this as little as possible.
    # If a property replacement exists, use it!
    #
    # DO NOT attempt to use .location or .rotation
    datablock_info: DatablockInfo

    # If Datablock is a MESH, these will correspond to (hopefully valid) entries in the idx table and _VT table
    start_idx: Optional[int]
    count: Optional[int]
    transform_animation: Optional[IntermediateAnimation]
    show_hide_animations: List[IntermediateAnimation]

    bake_matrix: Matrix

    # Why here? DatablockInfos are meant to be isolated structs as much as possible
    # and we're interested in the relationship between IntermediateDatablocks
    # and their animations which isn't data a DatablockInfo has
    children: List["IntermediateDatablock"] = field(default_factory=list)

    bins: Tuple[bool, bool, bool, bool] = field(
        default_factory=lambda: (False, False, False, False)
    )

    attr_light_level: Attr_light_level = None
    manipulator: Attr_manip = None

    def merge_verts(self, me) -> bpy.types.Mesh:
        # if the remove_doubles option is requested in the scene properties
        if bpy.context.scene.xplane.remove_doubles:
            bm = bmesh.new()   # create an empty BMesh
            bm.from_mesh(me)   # fill it in from a Mesh

            # remove the duplicate verts from the BMesh
            bmesh.ops.remove_doubles(bm, verts=bm.verts[:], dist=0.0001)

            # Finish up, write the bmesh back to the mesh
            bm.to_mesh(me)
        else:
            me

    def build_mesh(self, vt_table: "VTTable", material_name: str) -> bpy.types.Mesh:
        """
        Builds a mesh from the OBJ's VT Table, raises ValueError if
        an object with that mesh couldn't be built
        """
        mesh_idxes = vt_table.idxes[self.start_idx : self.start_idx + self.count]

        vertex_map_old_to_new = {}
        vertices = []
        for idx in mesh_idxes:
            if idx not in vertex_map_old_to_new:
                vertices.append(vt_table.vertices[idx])
                vertex_map_old_to_new[idx] = len(vertices) - 1
            else:
                pass
        idxes = [vertex_map_old_to_new[idx] for idx in mesh_idxes]
        normals = [(v.nx, v.ny, v.nz) for v in vertices]
        uvs = [Vector((v.s, v.t)) for v in vertices]

        # Thanks senderle, https://stackoverflow.com/a/22045226
        def chunk(it, size):
            it = iter(it)
            return iter(lambda: tuple(itertools.islice(it, size)), ())

        py_vertices = [(v.x, v.y, v.z) for v in vertices]
        py_faces: List[Tuple[int, int, int]] = [
            # We reverse the winding order to reverse the faces
            face[::-1]
            for face in chunk(idxes, 3)
        ]

        me = bpy.data.meshes.new(self.name)
        # check if the smoothing operation is requested in the scene properties
        if bpy.context.scene.xplane.auto_smooth:
            me.use_auto_smooth = True

        me.from_pydata(py_vertices, [], py_faces)

        if me.validate(verbose=True):
            logger.error(f"Invalid Mesh for object '{self.name}' was corrected, check console for more")

        # Thanks Dave Prue and their "Import X-Plane Object" addon for the API example
        me.uv_layers.new()

        for mesh_uv_loop, mesh_loop in zip(me.uv_layers[-1].data, me.loops):
            mesh_uv_loop.uv = uvs[mesh_loop.vertex_index]

#        try:
            # IMC for Blender 3+ this needs to use the new vertex_normals collection
            # as the vertex.normal property became readonly
#            for i, vertex_normal in enumerate(me.vertex_normals):
#                vertex_normal = normals[i]
#        except:
            # if we can't find vertex_normals, try it the old way
#            for i, vertex in enumerate(me.vertices):
#                vertex.normal = normals[i]

#        me.calc_normals()

        me.update(calc_edges=True)

        me.normals_split_custom_set_from_vertices(normals)

        # merge the nearby duplicate vertices
        self.merge_verts(me)

        ob = test_creation_helpers.create_datablock_mesh(
            self.datablock_info,
            mesh_src=me,
            material_name="Material" if material_name == None else material_name
        )
        ob.xplane.override_lods = any(self.bins)
        if ob.xplane.override_lods:
            for i, enabled in enumerate(self.bins):
                ob.xplane.lod[i] = enabled

        return ob

    @property
    def name(self) -> str:
        return self.datablock_info.name

    @property
    def parent(self) -> Optional[str]:
        try:
            return self.datablock_info.parent_info.parent
        except AttributeError:
            return None

    @parent.setter
    def parent(self, value: str) -> None:
        self.datablock_info.parent_info.parent = value

    @property
    def datablock_type(self) -> str:
        return self.datablock_info.datablock_type

    @property
    def is_animated(self) -> bool:
        return self.transform_animation or self.show_hide_animations

    @property
    def rotation_mode(self) -> str:
        """
        Calculates the final rotation_mode based on
        the back matrix and any animations it has.
        """
        # If its rotation or one of its animated rotations (if applicable)
        # is not axis_aligned, our Object will have Axis Angle rotation mode
        is_axis_aligned = is_vector_axis_aligned(
            self.bake_matrix.to_quaternion().to_axis_angle()[0]
        )
        if not self.transform_animation and is_axis_aligned:
            rotation_mode = "XYZ"
        elif not self.transform_animation and not is_axis_aligned:
            rotation_mode = "AXIS_ANGLE"
        # This is a very generalized check. See the rules for the rotations dict
        # in its definition
        elif any(
            not is_vector_axis_aligned(axis)
            for axis in self.transform_animation.rotations
        ):
            rotation_mode = "AXIS_ANGLE"
        else:
            # This is already figured out in finalize_intermediate_blocks
            rotation_mode = self.datablock_info.rotation_mode

        return rotation_mode


@dataclass
class VT:
    """Where xyz, nxyz are in Blender coords"""

    x: float
    y: float
    z: float
    nx: float
    ny: float
    nz: float
    s: float
    t: float

    def __post_init__(self):
        for attr, factory in type(self).__annotations__.items():
            try:
                setattr(self, attr, factory(getattr(self, attr)))
            except ValueError:
                print(
                    f"Couldn't convert '{attr}''s value ({getattr(self, attr)}) with {factory}"
                )

    def __str__(self) -> str:
        def fmt(s):
            try:
                return floatToStr(float(s))
            except (TypeError, ValueError):
                return s

        return "\t".join(
            fmt(value)
            for attr, value in vars(self).items()
            if not attr.startswith("__")
        )


@dataclass
class VTTable:
    vertices: List[VT] = field(default_factory=list)
    idxes: List[int] = field(default_factory=list)


@dataclass
class _AnimIntermediateStackEntry:
    animation: IntermediateAnimation
    intermediate_datablock: Optional[IntermediateDatablock]

class ImpCommandBuilder:
    def __init__(self, filepath: Path):
        self.root_collection = test_creation_helpers.create_datablock_collection(
            pathlib.Path(filepath).stem
        )

        self.root_collection.xplane.is_exportable_collection = True

        # If ATTR_LOD is used this becomes the LOD sub collections
        self.parent_collection = self.root_collection
        self.vt_table = VTTable([], [])
        self.texture: Optional[Path] = None
        # self.texture_lit:Optional[Path] = Path()
        # self.texture_normal:Optiona[Path] = Path()

        # Although we don't end up making this, it is useful for tree problems
        self.root_intermediate_datablock = IntermediateDatablock(
            datablock_info=DatablockInfo(
                datablock_type="EMPTY",
                name="INTER_ROOT",
                collection=self.parent_collection,
            ),
            start_idx=None,
            count=None,
            transform_animation=None,
            show_hide_animations=[],
            bake_matrix=Matrix.Identity(4)
        )

        # --- LODS -------------------------------------------------------------
        self.lod_mode: Optional[None] = None
        self.current_bins = (False, False, False, False)
        self.encountered_ranges: List[LODRange] = []
        # ---------------------------------------------------------------------
        # --- Animation Builder States ----------------------------------------
        # Instead of build at separate parent/child relationship in Datablock info, we just save everything we make here
        self._blocks: List[IntermediateDatablock] = [self.root_intermediate_datablock]
        self._last_axis: Optional[Vector] = None
        self._anim_intermediate_stack: Deque[
            _AnimIntermediateStackEntry
        ] = collections.deque()
        self._anim_count: Sequence[int] = collections.deque()
        self._bake_matrix_stack: Deque[Matrix] = collections.deque((Matrix(),))
        # ---------------------------------------------------------------------

        self.attr_light_level: Attr_light_level = None
        self.material_name: str = "Material"
        self.current_manipulator: Attr_manip = None

        self.cockpit_panel_tex: bool = False
        self.cockpit_device: Attr_cockpit_device = None

        self.draw_enabled: bool = True
        self.solid_camera: bool = False

    def get_material_name(self) -> str:
        name:str = None

        if self.cockpit_device != None:
            name = self.material_name + "_COCKPIT_" + self.cockpit_device.name
            # ensure the material exists and the properties are set up correctly
            if (test_creation_helpers.get_material(name) == None):
                # use the checkerboard texture for this one
                mat = test_creation_helpers.create_material(name, None)
                mat.xplane.draw = True
                mat.xplane.solid_camera = False
                mat.xplane.cockpit_feature = COCKPIT_FEATURE_DEVICE
                mat.xplane.device_name = self.cockpit_device.name
                # TODO: encode the bus information
                # mat.xplane.device_bus_{i}")
                mat.xplane.device_lighting_channel = self.cockpit_device.light_channel
                mat.xplane.device_auto_adjust = self.cockpit_device.auto_adjust
        elif self.cockpit_panel_tex:
            name = self.material_name + "_PANEL"
            if (test_creation_helpers.get_material(name) == None):
                # use the checkerboard texture for this one
                mat = test_creation_helpers.create_material(name, None)
                mat.xplane.draw = True
                mat.xplane.solid_camera = False
                mat.xplane.cockpit_feature = COCKPIT_FEATURE_PANEL
        elif self.draw_enabled:
            if self.solid_camera:
                name = self.material_name + "_SOLID"
                # ensure the material exists and the properties are set up correctly
                if (test_creation_helpers.get_material(name) == None):
                    mat = test_creation_helpers.create_material(name, self.texture)
                    mat.xplane.draw = True
                    mat.xplane.solid_camera = True
            else:
                name = self.material_name
                # ensure the material exists and the properties are set up correctly
                if (test_creation_helpers.get_material(name) == None):
                    mat = test_creation_helpers.create_material(name, self.texture)
                    mat.xplane.draw = True
                    mat.xplane.solid_camera = False
        else:
            if self.solid_camera:
                name = self.material_name + "_NO_DRAW_SOLID"
                # ensure the material exists and the properties are set up correctly
                if (test_creation_helpers.get_material(name) == None):
                    mat = test_creation_helpers.create_material(name, self.texture)
                    mat.xplane.draw = False
                    mat.xplane.solid_camera = True
            else:
                name = self.material_name + "_NO_DRAW"
                # ensure the material exists and the properties are set up correctly
                if (test_creation_helpers.get_material(name) == None):
                    mat = test_creation_helpers.create_material(name, self.texture)
                    mat.xplane.draw = False
                    mat.xplane.solid_camera = False
        return name

    def build_cmd(self, directive: str, *args: List[Union[float, int, str]], name_hint: str = ""):
        """
        Given the directive and it's arguments, correctly handle each case.

        args must be every arg, in order, correctly typed, needed to build the command
        """

        def begin_new_frame() -> None:
            if not self._top_intermediate_datablock:
                parent = self.root_intermediate_datablock
            else:
                parent = self._top_intermediate_datablock

            empty = IntermediateDatablock(
                datablock_info=DatablockInfo(
                    "EMPTY",
                    name=name_hint or self._next_empty_name(),
                    parent_info=ParentInfo(parent.datablock_info.name),
                    collection=self.parent_collection,
                ),
                start_idx=None,
                count=None,
                transform_animation=None,
                show_hide_animations=[],
                bake_matrix=self._bake_matrix_stack[-1].copy(),
                children=[],
                bins=tuple(self.current_bins),
            )
            self._blocks.append(empty)
            parent.children.append(empty)

            self._anim_intermediate_stack.append(
                _AnimIntermediateStackEntry(IntermediateAnimation(), empty)
            )
            self._anim_count[-1] += 1
            empty.transform_animation = self._top_animation
            self._bake_matrix_stack[-1].identity()

        def anim_begin():
            self._anim_count.append(0)
            self._bake_matrix_stack.append(self._bake_matrix_stack[-1].copy())

        def anim_end():
            for i in range(self._anim_count.pop()):
                self._anim_intermediate_stack.pop()
            self._bake_matrix_stack.pop()

        def anim_trans_begin(dataref_path: str):
            begin_new_frame()
            self._top_animation.xp_dataref = IntermediateDataref(
                anim_type=ANIM_TYPE_TRANSFORM,
                loop=0,
                path=dataref_path,
                show_hide_v1=0,
                show_hide_v2=0,
                location_values=[],
                rotation_values=[],
            )

        def anim_show_hide(v1: float, v2: float, dataref_path: str):
            begin_new_frame()
            self._top_dataref.anim_type = directive.replace("ANIM_", "")
            self._top_dataref.path = dataref_path
            self._top_dataref.show_hide_v1 = v1
            self._top_dataref.show_hide_v2 = v2

        def anim_trans_key(value: Vector, location: Vector):
            self._top_animation.locations.append(location)
            self._top_dataref.location_values.append(value)

        def anim_trans(xyz1: Vector, xyz2: Vector, v1: float, v2: float, path: str):
            r_xyz1, r_xyz2 = (
                round_vec(xyz, PRECISION_KEYFRAME) for xyz in [xyz1, xyz2]
            )
            r_v1, r_v2 = (round(v, PRECISION_KEYFRAME) for v in [v1, v2])

            def add_as_dynamic():
                begin_new_frame()
                self._top_animation.locations.append(xyz1)
                self._top_animation.locations.append(xyz2)
                self._top_dataref.location_values.extend((v1, v2))
                self._top_dataref.path = path

            if r_xyz1 == r_xyz2 and r_v1 == r_v2:
                # print("trans, case A - static")
                self._bake_matrix_stack[-1] = self._bake_matrix_stack[-1] @ Matrix.Translation(xyz1)
            elif r_xyz1 == r_xyz2 and r_v1 != r_v2:
                # print("trans, case B - as dynamic")
                add_as_dynamic()
            elif r_xyz1 != r_xyz2 and r_v1 == r_v2:
                # print("trans, case C - as odd dynamic")
                add_as_dynamic()
                # TODO: make warning
                line = "bleh"
                logger.warn(
                    f"ANIM_trans"
                    f"    {c for c in xyz1}"
                    f"    {c for c in xyz2}"
                    f"    {v1} {v2} {path}`"
                    f"on line {line} has different locations but the same dataref values - it is malformed."
                    f"Fix {self._anim_intermediate_stack[-1].intermediate_datablock}"
                )
            elif r_xyz1 != r_xyz2 and r_v1 != r_v2:
                # print("trans, case D - dynamic")
                add_as_dynamic()

        def anim_rotate_begin(axis: Vector, dataref_path: str):
            axis.normalize()

            self._last_axis = axis
            begin_new_frame()
            self._top_animation.xp_dataref = IntermediateDataref(
                anim_type=ANIM_TYPE_TRANSFORM,
                loop=0,
                path=dataref_path,
                show_hide_v1=0,
                show_hide_v2=0,
                location_values=[],
                rotation_values=[],
            )

        def anim_rotate_key(value: float, degrees: float):
            self._top_animation.rotations[self._last_axis.freeze()].append(degrees)
            self._top_dataref.rotation_values.append(value)

        def anim_rotate_end():
            self._last_axis = None

        def anim_rotate(dxyz: Vector, r1:float, r2:float, v1:float, v2:float, path: str):
            dxyz.normalize()
            r_r1, r_r2 = (round(r, PRECISION_KEYFRAME) for r in [r1, r2])
            r_v1, r_v2 = (round(v, PRECISION_KEYFRAME) for v in [v1, v2])

            def add_as_dynamic():
                begin_new_frame()
                self._top_animation.rotations[dxyz.freeze()].append(r1)
                self._top_animation.rotations[dxyz.freeze()].append(r2)
                self._top_dataref.rotation_values.extend((v1, v2))
                self._top_dataref.path = path

            if r_r1 == r_r2 and r_v1 == r_v2:
                # print("rot, case A - static")
                self._bake_matrix_stack[-1] = (
                    self._bake_matrix_stack[-1]
                    @ Quaternion(dxyz, math.radians(r1)).to_matrix().to_4x4()
                )
                # print(
                #     "to euler in ANIM_rotate",
                #     [
                #         f"{math.degrees(c):.8f}"
                #         for c in self._bake_matrix_stack[-1].to_euler()
                #     ],
                # )
            elif r_r1 == r_r2 and r_v1 != r_v2:
                # print("rot, case B - as dynamic")
                add_as_dynamic()
            elif r_r1 != r_r2 and r_v1 == r_v2:
                # print("rot, case C - as odd dynamic")
                add_as_dynamic()
                # TODO: make warning
                line = "bleh"
                logger.warn(
                    f"ANIM_rotate"
                    f"    {Vector(c for c in dxyz)}"
                    f"    {r1} {r2}"
                    f"    {v1} {v2}"
                    f"    {path}"
                    f"\nnon line {line} has different rotation but the same dataref values - it is malformed."
                    f"Fix {self._anim_intermediate_stack[-1].intermediate_datablock}"
                )
            elif r_r1 != r_r2 and r_v1 != r_v2:
                # print("rot, case D - dynamic")
                add_as_dynamic()

        def tris(start_idx: int, count: int, obj_name: str, transform_override: Vector = None):
            if not self._anim_intermediate_stack:
                parent: IntermediateDatablock = self.root_intermediate_datablock
            else:
                parent: IntermediateDatablock = self._anim_intermediate_stack[
                    -1
                ].intermediate_datablock

            mat = self._bake_matrix_stack[-1].copy()
            if transform_override != None:
                mat = mat @ Matrix.Translation(transform_override)

            intermediate_datablock = IntermediateDatablock(
                datablock_info=DatablockInfo(
                    datablock_type="MESH",
                    name=obj_name,
                    # How do we keep track of this
                    parent_info=ParentInfo(parent.datablock_info.name),
                    collection=self.parent_collection,
                ),
                start_idx=start_idx,
                count=count,
                transform_animation=None,
                show_hide_animations=[],
                bake_matrix=mat,
                children=[],
                bins=tuple(self.current_bins),
            )

            # derive the mesh-name from the current draw and solid camera state variables
            intermediate_datablock.material_name = self.get_material_name()

            if self.attr_light_level != None:
                intermediate_datablock.attr_light_level = self.attr_light_level

            if self.current_manipulator != None:
                intermediate_datablock.manipulator = self.current_manipulator

            self._blocks.append(intermediate_datablock)
            parent.children.append(intermediate_datablock)

        def fix_drag_rotate_missing_anim(xyz1: Vector, dxyz: Vector, dataref_path: str, v1_min: float, v1_max:float,
                                         angle1: float, angle2: float, start_idx: int, count: int, obj_name:str):
            # ANIM_begin
            anim_begin()
            # 	ANIM_trans	-0.15350001	0.25909999	2.5235	-0.15350001	0.25909999	2.5235
            anim_trans(xyz1, xyz1, 0, 0, None)
            # 	ANIM_rotate_begin	1	0	-0	sim/cockpit2/controls/elevator_trim
            anim_rotate_begin(dxyz, dataref_path)
            # 	ANIM_rotate_key	1	0
            anim_rotate_key(v1_min, angle1)
            # 	ANIM_rotate_key	-1	-600.00026
            anim_rotate_key(v1_max, angle2)
            # 	ANIM_rotate_end
            anim_rotate_end()
            # 		ATTR_draw_disable
            # 		ATTR_manip_drag_rotate	hand	-0.15350001	0.25909999	2.5235	1.000	0.000	-0.000	0.000	-600.000	0.000	1.000	-1.000	0.000	0.000	sim/cockpit2/controls/elevator_trim	none	Elevator Trim Control
            # 		TRIS	10290 120
            tris(start_idx, count, obj_name, -xyz1)
            # ANIM_end
            anim_end()

        if directive == "VT":
            self.vt_table.vertices.append(VT(*args))
        elif directive == "IDX":
            self.vt_table.idxes.append(args[0])
        elif directive == "IDX10":
            # idx error etc
            self.vt_table.idxes.extend(args)
        elif directive == "TRIS":
            start_idx = args[0]
            count = args[1]
            obj_name = name_hint or self._next_object_name()

            mesh_created = False
            # look for ATTR_manip_drag_rotate without an animation - animation fix need to be applied before we create the MESH block!
            if self.current_manipulator != None and self.current_manipulator.type == MANIP_DRAG_ROTATE and len(self._anim_intermediate_stack) == 0:
                logger.warn(f"object {obj_name} has a {MANIP_DRAG_ROTATE} manipulator but has no animation directives, this will not export!")
                # we can only fix the single dataref case at the moment!
                if self.current_manipulator.dataref2 == "none" and bpy.context.scene.xplane.manip_rotate_missing_anim_fixup:
                    logger.info(f"FIX APPLIED: object {obj_name}, {MANIP_DRAG_ROTATE} rotation animation fix")
                    fix_drag_rotate_missing_anim(self.current_manipulator.xyz1,
                                                 Vector((self.current_manipulator.dx, self.current_manipulator.dy, self.current_manipulator.dz)),
                                                 self.current_manipulator.dataref1,
                                                 self.current_manipulator.v1_min,
                                                 self.current_manipulator.v1_max,
                                                 self.current_manipulator.v1,
                                                 self.current_manipulator.v2,
                                                 start_idx, count, obj_name)
                    # the fix has already created the mesh handling the TRIS block
                    mesh_created = True

            if not mesh_created:
                tris(start_idx, count, obj_name)

        elif directive == "ATTR_LOD":
            near, far = args[:2]
            self.parent_collection = test_creation_helpers.create_datablock_collection(
                f"LOD_{near}_{far}", parent=self.root_collection
            )
            if self.lod_mode == None:
                # TODO: X-Plane default?
                self.lod_mode = "selective"
            if not self.encountered_ranges:
                self.current_bins = [True, False, False, False]
            elif near == self.encountered_ranges[-1].far:
                self.lod_mode = "selective"
                # TODO: too many ranges bug
                self.current_bins = [False, False, False, False]
                self.current_bins[len(self.encountered_ranges)] = True
            elif self.encountered_ranges[-1].near == 0:
                self.lod_mode = "additive"
                # TODO : too many ranges bug still
                self.current_bins = ([True] * (len(self.encountered_ranges) + 1)) + (
                    [False] * (4 - len(self.encountered_ranges) - 1)
                )
            assert len(self.current_bins) == 4, f"{self.current_bins}"
            self.encountered_ranges.append(LODRange(near, far))

        elif directive == "ANIM_begin":
            anim_begin()
        elif directive == "ANIM_end":
            anim_end()
        elif directive == "ANIM_trans_begin":
            dataref_path = args[0]
            anim_trans_begin(dataref_path)
        elif directive == "ANIM_trans_key":
            value = args[0]
            location = args[1]
            anim_trans_key(value, location)
        elif directive == "ANIM_trans_end":
            pass
        elif directive in {"ANIM_show", "ANIM_hide"}:
            v1, v2 = args[:2]
            dataref_path = args[2]
            anim_show_hide(v1, v2, dataref_path)
        elif directive == "ANIM_rotate_begin":
            axis = args[0]
            dataref_path = args[1]
            anim_rotate_begin(axis, dataref_path)
        elif directive == "ANIM_rotate_key":
            value = args[0]
            degrees = args[1]
            anim_rotate_key(value, degrees)
        elif directive == "ANIM_rotate_end":
            anim_rotate_end()
        elif directive == "ANIM_keyframe_loop":
            loop = args[0]
            self._top_dataref.loop = loop
        elif directive == "ANIM_trans":
            xyz1, xyz2 = args[0:2]
            v1, v2 = args[2:4]
            path = args[4]
            anim_trans(xyz1, xyz2, v1, v2, path)

        elif directive == "ANIM_rotate":
            dxyz = args[0]
            r1, r2 = args[1:3]
            v1, v2 = args[3:5]
            path = args[5]
            anim_rotate(dxyz, r1, r2, v1, v2, path)

        # ============================
        # light_level state management
        # ============================
        elif directive == "ATTR_light_level":
            self.attr_light_level = Attr_light_level(v1=args[0], v2=args[1], path=args[2])
        elif directive == "ATTR_light_level_reset":
            self.attr_light_level = None

        # ============================
        # Drawing state management
        # ============================
        elif directive == "ATTR_draw_disable":
            self.draw_enabled = False
        elif directive == "ATTR_draw_enable":
            self.draw_enabled = True

        # =================================
        # Camera collision state management
        # =================================
        elif directive =="ATTR_solid_camera":
            self.solid_camera = True
        elif directive == "ATTR_no_solid_camera":
            self.solid_camera = False

        # =============
        # MANIPULATORS
        # =============
        elif directive == "ATTR_manip_none":
            self.current_manipulator = None
        elif directive == "ATTR_manip_drag_xy":
            self.current_manipulator = Attr_manip(type=MANIP_DRAG_XY, cursor=args[0],
                                                  dx=float(args[1]), dy=float(args[2]),
                                                  v1_min=float(args[3]), v1_max=float(args[4]),
                                                  v2_min=float(args[5]), v2_max=float(args[6]),
                                                  dataref1=args[7], dataref2=args[8],
                                                  tooltip=args[9])
        elif directive == "ATTR_manip_drag_axis":
            self.current_manipulator = Attr_manip(type=MANIP_DRAG_AXIS, cursor=args[0],
                                                  dx=float(args[1]), dy=float(args[2]), dz=float(args[3]),
                                                  v1=float(args[4]), v2=float(args[5]),
                                                  dataref1=args[6],
                                                  tooltip=args[7])
        elif directive == "ATTR_manip_command":
            self.current_manipulator = Attr_manip(type=MANIP_COMMAND, cursor=args[0], command=args[1], tooltip=args[2])
        elif directive == "ATTR_manip_command_axis":
            self.current_manipulator = Attr_manip(type=MANIP_COMMAND_AXIS, cursor=args[0],
                                                  dx=float(args[1]), dy=float(args[2]), dz=float(args[3]),
                                                  positive_command=args[4], negative_command=args[5],
                                                  tooltip=args[6])
        elif directive == "ATTR_manip_noop":
            self.current_manipulator = Attr_manip(type=MANIP_NOOP)
        elif directive == "ATTR_manip_push":
            self.current_manipulator = Attr_manip(type=MANIP_PUSH, cursor=args[0],
                                                  v_down=float(args[1]), v_up=float(args[2]),
                                                  dataref1=args[3], tooltip=args[4])
        elif directive == "ATTR_manip_radio":
            self.current_manipulator = Attr_manip(type=MANIP_RADIO, cursor=args[0],
                                                  v_down=float(args[1]),
                                                  dataref1=args[2],
                                                  tooltip=args[3])
        elif directive == "ATTR_manip_toggle":
            self.current_manipulator = Attr_manip(type=MANIP_TOGGLE, cursor=args[0],
                                                  v1=float(args[1]), v2=float(args[2]),
                                                  dataref1=args[3], tooltip=args[4])
        elif directive == "ATTR_manip_delta":
            self.current_manipulator = Attr_manip(type=MANIP_DELTA, cursor=args[0],
                                                  v_down=float(args[1]), v_hold=float(args[2]),
                                                  v1_min=float(args[3]), v1_max=float(args[4]),
                                                  dataref1=args[5],
                                                  tooltip=args[6])
        elif directive == "ATTR_manip_wrap":
            self.current_manipulator = Attr_manip(type=MANIP_WRAP, cursor=args[0],
                                                  v_down=float(args[1]), v_hold=float(args[2]),
                                                  v1_min=float(args[3]), v1_max=float(args[4]),
                                                  dataref1=args[5],
                                                  tooltip=args[6])
        elif directive == "ATTR_manip_drag_axis_pix":
            self.current_manipulator = Attr_manip(type=MANIP_DRAG_AXIS_PIX, cursor=args[0],
                                                  dx=float(args[1]), step=float(args[2]),
                                                  exp=float(args[3]), v1=float(args[4]), v2=float(args[5]),
                                                  dataref1=args[6],
                                                  tooltip=args[7]
                                                  )
        elif directive == "ATTR_manip_command_knob":
            self.current_manipulator = Attr_manip(type=MANIP_COMMAND_KNOB, cursor=args[0],
                                                  positive_command=args[1], negative_command=args[2], tooltip=args[3])
        elif directive == "ATTR_manip_command_knob2":
            self.current_manipulator = Attr_manip(type=MANIP_COMMAND_KNOB2, cursor=args[0],
                                                  command=args[1], tooltip=args[2])
        elif directive == "ATTR_manip_command_switch_up_down":
            self.current_manipulator = Attr_manip(type=MANIP_COMMAND_SWITCH_UP_DOWN, cursor=args[0],
                                                  positive_command=args[1], negative_command=args[2], tooltip=args[3])
        elif directive == "ATTR_manip_command_switch_up_down2":
            self.current_manipulator = Attr_manip(type=MANIP_COMMAND_SWITCH_UP_DOWN2, cursor=args[0],
                                                  command=args[1], tooltip=args[2])

        elif directive == "ATTR_manip_command_switch_left_right":
            self.current_manipulator = Attr_manip(type=MANIP_COMMAND_SWITCH_LEFT_RIGHT, cursor=args[0],
                                                  positive_command=args[1], negative_command=args[2], tooltip=args[3])
        elif directive == "ATTR_manip_command_switch_left_right2":
            self.current_manipulator = Attr_manip(type=MANIP_COMMAND_SWITCH_LEFT_RIGHT2, cursor=args[0],
                                                  command=args[1], tooltip=args[2])
        elif directive == "ATTR_manip_axis_knob":
            self.current_manipulator = Attr_manip(type=MANIP_AXIS_KNOB,
                                                  cursor=args[0],
                                                  v1=float(args[1]), v2=float(args[2]),
                                                  click_step=float(args[3]), hold_step=float(args[4]),
                                                  dataref1=args[5],
                                                  tooltip=args[6])
        elif directive == "ATTR_manip_axis_switch_up_down":
            self.current_manipulator = Attr_manip(type=MANIP_AXIS_SWITCH_UP_DOWN,
                                                  cursor=args[0],
                                                  v1=float(args[1]), v2=float(args[2]),
                                                  click_step=float(args[3]), hold_step=float(args[4]),
                                                  dataref1=args[5],
                                                  tooltip=args[6])
        elif directive == "ATTR_manip_axis_switch_left_right":
            self.current_manipulator = Attr_manip(type=MANIP_AXIS_SWITCH_LEFT_RIGHT,
                                                  cursor=args[0],
                                                  v1=float(args[1]), v2=float(args[2]),
                                                  click_step=float(args[3]), hold_step=float(args[4]),
                                                  dataref1=args[5],
                                                  tooltip=args[6])
        elif directive == "ATTR_manip_drag_rotate":
            self.current_manipulator = Attr_manip(type=MANIP_DRAG_ROTATE, cursor=args[0],
                                                  xyz1 = args[1],
                                                  dx = args[2][0],
                                                  dy = args[2][1],
                                                  dz = args[2][2],
                                                  v1 = float(args[3]),
                                                  v2 = float(args[4]),
                                                  v_up = float(args[5]),
                                                  v1_min=float(args[6]),
                                                  v1_max=float(args[7]),
                                                  v2_min=float(args[8]),
                                                  v2_max=float(args[9]),
                                                  dataref1=args[10],
                                                  dataref2=args[11],
                                                  tooltip=args[12])
            logger.warn(F"Manipulator {directive} is not yet fully handled - check your model!")

        # =====================
        # MANIPULATOR MODIFIERS
        # =====================
        #elif directive == "ATTR_manip_keyframe":
        elif directive == "ATTR_manip_wheel":
            if self.current_manipulator != None:
                self.current_manipulator.wheel_delta = float(args[0])
        # applies only to DRAG_AXIS (spec) and DRAG_ROTATE (code)
        elif directive == "ATTR_axis_detented":
            if self.current_manipulator == None:
                logger.warn(f"ATTR_axis_detented requires an existing ATTR_manip_drag_axis or ATTR_manip_drag_rotate")
            elif self.current_manipulator.type == MANIP_DRAG_AXIS:
                # change the type
                self.current_manipulator.type = MANIP_DRAG_AXIS_DETENT
            elif self.current_manipulator.type == MANIP_DRAG_ROTATE:
                # change the type
                self.current_manipulator.type = MANIP_DRAG_ROTATE_DETENT
            else:
                logger.warn(f"ATTR_axis_detented can only be applied to an ATTR_manip_drag_axis or ATTR_manip_drag_rotate")

            # now apply the values
            self.current_manipulator.dx = float(args[0])
            self.current_manipulator.dy = float(args[1])
            self.current_manipulator.dz = float(args[2])
            self.current_manipulator.v1_min = float(args[3])
            self.current_manipulator.v1_max = float(args[4])
            self.current_manipulator.dataref1 = args[5]
        # applies only to DRAG_AXIS (spec) and DRAG_ROTATE (code)
        elif directive == "ATTR_axis_detent_range":
            if self.current_manipulator != None:
                # adding detents to a drag_axis or drag_rotate?
                if self.current_manipulator.type == MANIP_DRAG_AXIS:
                    self.current_manipulator.type = MANIP_DRAG_AXIS_DETENT
                elif self.current_manipulator.type == MANIP_DRAG_ROTATE:
                    self.current_manipulator.type = MANIP_DRAG_ROTATE_DETENT

                # apply the values
                if (self.current_manipulator.type == MANIP_DRAG_AXIS_DETENT or
                    self.current_manipulator.type == MANIP_DRAG_ROTATE_DETENT):

                    self.current_manipulator.detents.append((float(args[0]), float(args[1]), float(args[2])))
                else:
                    logger.warn(f"ATTR_axis_detent_range can only be applied to an ATTR_manip_drag_axis or ATTR_manip_drag_rotate which is detented")
            else:
                logger.warn(f"ATTR_axis_detent_range requires an active manipulator to apply to!")

        # =====================
        # cockpit attributes
        # =====================
        elif directive == "ATTR_cockpit":
            self.current_manipulator = None
            self.cockpit_panel_tex = True
        elif directive == "ATTR_cockpit_lit_only":
            self.current_manipulator = None
            self.cockpit_panel_tex = True
        #elif directive == "ATTR_cockpit_region":
        elif directive == "ATTR_no_cockpit":  # off
            self.cockpit_panel_tex = False
        elif directive == "ATTR_cockpit_device":
            self.cockpit_device = Attr_cockpit_device(name=args[0], bus=args[1], light_channel=int(args[2]), auto_adjust=int(args[3]))

        # ====================
        # lights
        # ====================
        #elif directive == "LIGHTS":
        elif directive== "LIGHT_NAMED":
            name = args[0]
            xyz1 = args[1]

            if not self._anim_intermediate_stack:
                parent: IntermediateDatablock = self.root_intermediate_datablock
            else:
                parent: IntermediateDatablock = self._anim_intermediate_stack[
                    -1
                ].intermediate_datablock

            intermediate_datablock = IntermediateDatablock(
                datablock_info=DatablockInfo(
                    datablock_type="LIGHT",
                    name=name_hint or self._next_object_name(),
                    # How do we keep track of this
                    parent_info=ParentInfo(parent.datablock_info.name),
                    collection=self.parent_collection
                ),
                start_idx=0,
                count=0,
                transform_animation=None,
                show_hide_animations=[],
                bake_matrix=self._bake_matrix_stack[-1].copy() @ Matrix.Translation(xyz1),
                children=[],
                bins=tuple(self.current_bins)
            )

            intermediate_datablock.light_type = LIGHT_PARAM
            intermediate_datablock.light_name = name

            self._blocks.append(intermediate_datablock)
            parent.children.append(intermediate_datablock)
        #elif directive == "LIGHT_CUSTOM":
        elif directive == "LIGHT_PARAM":
            name = args[0]
            xyz1 = args[1]
            params = args[2]

            if not self._anim_intermediate_stack:
                parent: IntermediateDatablock = self.root_intermediate_datablock
            else:
                parent: IntermediateDatablock = self._anim_intermediate_stack[
                    -1
                ].intermediate_datablock

            intermediate_datablock = IntermediateDatablock(
                datablock_info=DatablockInfo(
                    datablock_type="LIGHT",
                    name=name_hint or self._next_object_name(),
                    # How do we keep track of this
                    parent_info=ParentInfo(parent.datablock_info.name),
                    collection=self.parent_collection
                ),
                start_idx=0,
                count=0,
                transform_animation=None,
                show_hide_animations=[],
                bake_matrix=self._bake_matrix_stack[-1].copy() @ Matrix.Translation(xyz1),
                children=[],
                bins=tuple(self.current_bins)
            )

            intermediate_datablock.light_type = LIGHT_PARAM
            intermediate_datablock.light_name = name
            intermediate_datablock.light_params = params

            self._blocks.append(intermediate_datablock)
            parent.children.append(intermediate_datablock)
        #elif directive == "LIGHT_SPILL_CUSTOM":

        else:
            assert False, f"{directive} is not supported yet"

    def finalize_intermediate_blocks(self) -> Set[str]:
        """The last step after parsing, converting
        data to intermediate structures, clean up and error checking.

        Returns a set with FINISHED or CANCELLED, matching the returns of bpy
        operators
        """

        def reparent_children_to_new_block(
            current_parent_block: IntermediateDatablock,
            new_parent_block: IntermediateDatablock,
        ):
            for child in current_parent_block.children:
                child.datablock_info.parent_info.parent = (
                    new_parent_block.datablock_info.name
                )
            current_parent_block.children.clear()

        # Since we're using root collections mode, our INTER_ROOT empty datablock isn't made
        # and we pretend its a collection.
        blocks_rem_itr = islice(self._blocks, 1, len(self._blocks))
        while True:
            try:
                intermediate_block = next(blocks_rem_itr)
            except StopIteration:
                break
            else:
                intermediate_name = intermediate_block.datablock_info.name
                intermediate_block_type = intermediate_block.datablock_type
                intermediate_parent = intermediate_block.parent
                if intermediate_block.parent == "INTER_ROOT":
                    intermediate_block.datablock_info.parent_info = None
                intermediate_parent_info = intermediate_block.datablock_info.parent_info

            print(
                f"Deciding {intermediate_block.name}" f", parent {intermediate_parent}"
            )

            if intermediate_block_type == "EMPTY":
                # Remember, we only make empties to store animations so no try needed here

                def optimize_empty_chain(
                    in_block: IntermediateDatablock,
                    searching_itr: Iterator[IntermediateDatablock],
                ) -> Tuple[IntermediateDatablock, Iterator[IntermediateDatablock]]:
                    """
                    Cleans and optimizes IntermediateDatablocks to produce the final blocks to be created.

                    Returns next block to be created and an iterator to keep searching.

                    Current optimizations
                    Optimization                   | Requires...                                      | next_block
                    -------------------------------|--------------------------------------------------|-----------
                    merge_dref_trans_table         | is_in_block_loc_anim and is_next_block_loc_anim  |
                    add_trans_table                | both loc_anim, same rotation dref values         |
                    merge_orthogonal_rotation_axis | both rot_anim, same xp_dataref.rotation_values   | reparent children
                    take_next_block_rotations      | not in_block rot_anim, is_next_block_rot_anim    | reparent children
                    # merge_show_hide_animations   | not (is_loc_anim or is_rot_anim)                 | reparent children
                    - For the same dataref path and values, 3 orthogonal axis in a row are merged
                    - Duplicate location lists, rotations, and show/hides overwrite previous values
                    - Sequential ANIM_show/hides are merged
                    - TRIS take animations from parent empties, reducing parents

                    Arbitrary rotation axis are not supported (anywhere), locations and rotations even for the same dataref path and values are not skipped

                    Not Optimized (Yet!)
                    - Optimize out duplicate Show/Hide
                    - Sequential Axis Angle dynamic rotations with the same axis and dataref are merged into one

                    TODO Algorithms
                    - Don't reduce locations when locations are different but dataref values are same.
                    This requires user attention to fix
                    """
                    i = -1
                    while True:
                        in_block_type = in_block.datablock_type
                        in_block_animation = in_block.transform_animation
                        in_block_dataref = in_block_animation.xp_dataref
                        in_block_path = in_block_dataref.path
                        is_in_block_loc_anim = bool(in_block_animation.locations)
                        is_in_block_rot_anim = bool(in_block_animation.rotations)
                        i += 1
                        searching_itr, peek_next_block_itr = itertools.tee(
                            searching_itr
                        )

                        try:
                            next_block = next(peek_next_block_itr)
                        except StopIteration:
                            # TODO: Wait! What about self optimizations!
                            # No next block, nothing to accumulate
                            break
                        else:
                            next_name = next_block.name
                            print("next name ", next_name)
                            next_block_type = next_block.datablock_type
                            next_block_parent = next_block.parent
                            next_show_hide_animations = next_block.show_hide_animations
                            next_animation = next_block.transform_animation
                            try:
                                next_dataref = next_animation.xp_dataref
                                next_block_path = next_dataref.path
                                is_next_block_loc_anim = bool(next_animation.locations)
                                is_next_block_rot_anim = bool(next_animation.rotations)
                            except AttributeError:
                                next_dataref = None
                                next_block_path = None
                                is_next_block_loc_anim = False
                                is_next_block_rot_anim = False

                            if next_block_type == "MESH":
                                # TODO: Needs unit test showing replacement happens only with 1 child mesh
                                # multiple child meshes or mixed child meshes and empties doesn't work
                                if len(in_block.children) == 1:
                                    next_block.transform_animation = copy.copy(
                                        in_block.transform_animation
                                    )
                                    next_block.show_hide_animations = copy.copy(
                                        in_block.show_hide_animations
                                    )
                                    next_block.datablock_info.parent_info = copy.copy(
                                        in_block.datablock_info.parent_info
                                    )
                                return next_block, peek_next_block_itr
                            elif (
                                next_block_type == "EMPTY"
                                and in_block_path == next_block_path
                            ):
                                assert "" not in {
                                    in_block_path,
                                    next_block_path,
                                }, "EMPTY cannot have no dataref"
                                # WHEN DO WE SKIP THEN NEXT BLOCK?
                                assert (
                                    next_block.is_animated
                                ), f"{next_name} is EMPTY and must have animations"

                                def merge_dref_trans_table() -> IntermediateDatablock:
                                    """
                                    Merges the translation tables of in_block and next_block,
                                    returning an altered in_block and reparenting next_block's children
                                    to in_block

                                    Covers cases like

                                    ANIM_trans VecA VecB   0 1  dref1
                                    ANIM_trans VecC VecD   3 4  dref1
                                    ANIM_trans VecE VecF   -2 2 dref1
                                    TRIS 3 3

                                    dref1, 6 frames
                                    Frame | Value | Vector
                                    ------|-------|-------
                                    1     | -2    | VecE
                                    2     | 0     | VecA
                                    3     | 1     | VecB
                                    4     | 2     | VecF
                                    5     | 3     | VecC
                                    6     | 4     | VecD

                                    This is not necissarily the end of optimizations. In this example TRIS gets this table
                                    """
                                    merged_locations = collections.defaultdict(list)
                                    for location, dref_value in itertools.chain(
                                        in_block_animation.locations,
                                        next_animation.locations,
                                    ):
                                        r_location = round_vec(
                                            location, PRECISION_KEYFRAME
                                        )
                                        # if
                                        # merged_locations[round_vec(location, PRECISION_KEYFRAME)].append(dref_value

                                if is_in_block_loc_anim and is_next_block_loc_anim:
                                    # TODO:
                                    # in_block = merge_dref_trans_table()
                                    # searching_itr = peek_next_block_itr
                                    pass

                                def add_overlaping_tables():
                                    """

                                    ANIM_trans    VecA VecB   0 1 dref1
                                    ANIM_trans    VecC VecD   0 1 dref1
                                    ANIM_trans_begin dref1
                                        ANIM_trans 0  VecE
                                        ANIM_trans 2 VecF
                                    ANIM_trans_end

                                    In this case a new table is produced
                                    ANIM_trans    VecA+VecC VecB+VecD    0 1 dref1
                                    ANIM_trans_begin dref1
                                        ANIM_trans 0 VecA+VecC+VecE
                                        ANIM_trans 1 VecB+VecD
                                        ANIM_trans 2 VecF
                                    ANIM_trans_end
                                    """
                                    pass

                                # TODO: Assumes dataref ranges are the same
                                def merge_orthogonal_rotation_axis() -> IntermediateDatablock:
                                    print("merge orthogonal axis")
                                    """
                                    Attempts to merge any mergable rotations of the next_block into
                                    the in_block. Raises ValueError if next_block has nothing to merge.

                                    Assumes that the dataref ranges are the same
                                    """
                                    merge_count = 0
                                    rotations = in_block.transform_animation.rotations
                                    for (
                                        axis,
                                        degrees,
                                    ) in next_animation.rotations.items():
                                        is_axis_aligned = is_vector_axis_aligned(axis)

                                        already_used = any(
                                            round_vec(axis, PRECISION_KEYFRAME)
                                            == round_vec(vec, PRECISION_KEYFRAME)
                                            for vec in rotations
                                        )
                                        # print("is_axis_aligned:", is_axis_aligned)
                                        # print("already_used:", already_used)

                                        if is_axis_aligned and not already_used:
                                            # print("merging: ", axis)
                                            in_block_animation.rotations[axis] = degrees
                                            merge_count += 1
                                        else:
                                            # print("not merging: ", axis)
                                            pass

                                    if merge_count:
                                        reparent_children_to_new_block(
                                            next_block,
                                            in_block,
                                        )
                                    else:
                                        raise ValueError

                                    return in_block

                                if is_in_block_rot_anim and is_next_block_rot_anim:
                                    print(
                                        " rea if is_in_block_rot_anim and is_next_block_rot_anim:"
                                    )
                                    # First we see if we can do our special extra
                                    # smart merge_orthogonal_rotation_axis merge,
                                    # Otherwise we just copy and reparent the next block's
                                    try:
                                        if (
                                            in_block_animation.xp_dataref.rotation_values
                                            == next_animation.xp_dataref.rotation_values
                                        ):
                                            in_block = merge_orthogonal_rotation_axis()
                                            searching_itr = peek_next_block_itr
                                        else:
                                            raise ValueError
                                    except ValueError:
                                        pass

                                def take_next_block_rotations():
                                    in_block_animation.rotations = copy.copy(
                                        next_animation.rotations
                                    )
                                    in_block_animation.xp_dataref.rotation_values = (
                                        copy.copy(
                                            next_animation.xp_dataref.rotation_values
                                        )
                                    )
                                    reparent_children_to_new_block(next_block, in_block)

                                    return in_block

                                if (
                                    not in_block_animation.is_animated_rotation
                                    and in_block_dataref.rotation_values
                                    == next_dataref.rotation_values
                                ):
                                    # TODO: What the heck is this?
                                    in_block = take_next_block_rotations()
                                    searching_itr = peek_next_block_itr

                                # Merge Show/Hides
                                def merge_show_hide_animations():
                                    """
                                    If the next EMPTY is simply a show/hide,
                                    absorb it's animations
                                    """
                                    for next_anim in (
                                        next_anim
                                        for next_anim in next_show_hide_animations
                                        if next_anim.anim_type
                                        in {ANIM_TYPE_SHOW, ANIM_TYPE_HIDE}
                                    ):
                                        print(
                                            f"{in_block.name} from show/hide from {next_name}"
                                        )
                                        in_block.show_hide_animations.append(next_anim)

                                if next_show_hide_animations:
                                    show_hide_count = len(in_block.show_hide_animations)
                                    merge_show_hide_animations()
                                    if (
                                        len(in_block.show_hide_animations)
                                        - show_hide_count
                                    ):
                                        reparent_children_to_new_block(
                                            next_block,
                                            in_block,
                                        )
                                        searching_itr = peek_next_block_itr
                                # We have no more optimizations to apply to two blocks with
                                # the same dataref paths, move iterator
                                # next(searching_itr)
                                print("normal searching)itr = peeknextblock")
                            # --- end next empty with same dataref -------------
                            elif (
                                next_block_type == "EMPTY"
                                and in_block_path != next_block_path
                            ):
                                # Different dataref = search complete.
                                # outer loop will advance itr
                                return (in_block, searching_itr)

                            else:
                                assert False, f"{next_block_type} is not yet supported"

                            # What we need: Big if statement to collect optimizations to run, in what order, what should be done to the intermediate block, if you're getting rid of it who to reparent to, what shuold happen to the next block. We need a big ordered table.

                            # end if False
                    # end while
                    return (in_block, searching_itr)

                # end def optimize_empty_chain
                print(f"IN {intermediate_block.name}")
                out_block = intermediate_block
                # out_block, blocks_rem_itr = optimize_empty_chain(
                # intermediate_block, blocks_rem_itr
                # )
                #                print(
                #                    "location values",
                #                    out_block.transform_animation.xp_dataref.location_values,
                #                )
                #                print(
                #                    "rotation values",
                #                    out_block.transform_animation.xp_dataref.rotation_values,
                #                )

                print(
                    f"OUT {out_block.name}, parent: {out_block.parent}, type: {out_block.datablock_type}"
                )
            elif intermediate_block_type == "MESH":
                out_block = intermediate_block
            elif intermediate_block_type == "LIGHT":
                out_block = intermediate_block

            def fill_in_eulers(
                block_to_fill: IntermediateDatablock,
            ) -> Tuple[Dict[Vector, List[float]], str]:
                """
                Returns Euler rotations as a complete 3 entry dictionary, any holes filled in,
                and its accompanying rotation_mode.

                block_to_fill must be animated for rotation with
                axis-aligned vectors only.
                """

                degrees = [0.0] * len(
                    block_to_fill.transform_animation.xp_dataref.rotation_values
                )
                filled_rotations = {
                    "X": [Vector((1, 0, 0)).freeze(), degrees.copy()],
                    "Y": [Vector((0, 1, 0)).freeze(), degrees.copy()],
                    "Z": [Vector((0, 0, 1)).freeze(), degrees.copy()],
                }

                in_order = ""
                for (
                    axis,
                    degrees,
                ) in block_to_fill.transform_animation.rotations.items():
                    r_axis = tuple(
                        map(lambda c: bool(round(c, PRECISION_KEYFRAME)), axis)
                    )
                    axis_label = ["X", "Y", "Z"][r_axis.index(True)]
                    filled_rotations[axis_label] = [
                        axis.freeze(),
                        degrees,
                    ]
                    in_order += axis_label
                # If not all axis of an apparent Euler rotation
                # were given in the OBJ, we fix the rotation mode
                # based on some assumptions of what would have been good for
                # X-Plane
                if len(in_order) == 1:
                    corrected_order = "ZYX"
                elif len(in_order) == 2:
                    corrected_order = {
                        "XY": "XYZ",
                        "YZ": "XYZ",
                        "XZ": "XYZ",
                        "YX": "ZYX",
                        "ZY": "ZYX",
                        "ZX": "ZYX",
                    }[in_order]

                elif len(in_order) == 3:
                    corrected_order = in_order

                # Any good exporter would take XYZ and write
                # it as X-Plane's ZYX. The importer goes in
                # reverse
                rotation_mode = {
                    "XYZ": "ZYX",
                    "YXZ": "ZXY",
                    "XZY": "YZX",
                    "ZXY": "YXZ",
                    "YZX": "XZY",
                    "ZYX": "XYZ",
                }[corrected_order]

                # Sorting the dictionary is added only as a debugging convenience
                return (
                    {
                        axis: degrees
                        for axis_label, (axis, degrees) in sorted(
                            filled_rotations.items(),
                            key=lambda kv: rotation_mode.index(kv[0]),
                        )
                    },
                    rotation_mode,
                )

            try:
                is_all_euler = out_block.transform_animation.rotations and all(
                    is_vector_axis_aligned(axis)
                    for axis in out_block.transform_animation.rotations
                )
            except AttributeError:  # No transform_animation
                pass
            else:
                if is_all_euler:
                    (
                        out_block.transform_animation.rotations,
                        out_block.datablock_info.rotation_mode,
                    ) = fill_in_eulers(out_block)

            if out_block.datablock_type == "EMPTY":
                ob = test_creation_helpers.create_datablock_empty(
                    out_block.datablock_info,
                    empty_display_size=0.05,
                )
            elif out_block.datablock_type == "MESH":
                try:
                    ob = out_block.build_mesh(self.vt_table, out_block.material_name)
                except ValueError:
                    ob = None
                else:
                    if self.texture:
                        test_creation_helpers.set_material(
                            ob, out_block.material_name, texture_image=self.texture
                        )
            elif out_block.datablock_type == "LIGHT":
                ob = test_creation_helpers.create_datablock_light(out_block.datablock_info, "SPOT")
                ob.data.xplane.type = out_block.light_type
                ob.data.xplane.name = out_block.light_name
                if out_block.light_params != None:
                    ob.data.xplane.params = out_block.light_params

            if ob:
                ob.matrix_local = out_block.bake_matrix.copy()
                bpy.context.view_layer.update()

                ob.rotation_mode = out_block.rotation_mode

                try:
                    out_block.transform_animation.apply_animation(ob)
                except AttributeError:  # No transform animation
                    pass

                for animation in out_block.show_hide_animations:
                    animation.apply_animation(ob)

                if out_block.attr_light_level != None:
                    ob.xplane.lightLevel_v1 = out_block.attr_light_level.v1
                    ob.xplane.lightLevel_v2 = out_block.attr_light_level.v2
                    ob.xplane.lightLevel_dataref = out_block.attr_light_level.path
                    ob.xplane.lightLevel = True

                if out_block.manipulator != None:
                    manip = out_block.manipulator
                    ob.xplane.manip.enabled = True
                    ob.xplane.manip.autodetect_datarefs = False
                    ob.xplane.manip.type = manip.type
                    ob.xplane.manip.cursor = manip.cursor
                    ob.xplane.manip.tooltip = manip.tooltip
                    ob.xplane.manip.dx = manip.dx
                    ob.xplane.manip.dy = manip.dy
                    ob.xplane.manip.dz = manip.dz
                    ob.xplane.manip.v1 = manip.v1
                    ob.xplane.manip.v2 = manip.v2
                    ob.xplane.manip.v1_min = manip.v1_min
                    ob.xplane.manip.v1_max = manip.v1_max
                    ob.xplane.manip.v2_min = manip.v2_min
                    ob.xplane.manip.v2_max = manip.v2_max
                    ob.xplane.manip.v_down = manip.v_down
                    ob.xplane.manip.v_up = manip.v_up
                    ob.xplane.manip.v_hold = manip.v_hold
                    ob.xplane.manip.v_on = manip.v_on
                    ob.xplane.manip.v_off = manip.v_off
                    ob.xplane.manip.command = manip.command
                    ob.xplane.manip.positive_command = manip.positive_command
                    ob.xplane.manip.negative_command = manip.negative_command
                    ob.xplane.manip.dataref1 = manip.dataref1
                    ob.xplane.manip.dataref2 = manip.dataref2
                    ob.xplane.manip.step = manip.step
                    ob.xplane.manip.click_step = manip.click_step
                    ob.xplane.manip.hold_step = manip.hold_step
                    ob.xplane.manip.wheel_delta = manip.wheel_delta
                    ob.xplane.manip.exp = manip.exp
                    # add any detents
                    for detent in manip.detents:
                        ob.xplane.manip.axis_detent_ranges.add()
                        ob.xplane.manip.axis_detent_ranges[-1].start = detent[0]
                        ob.xplane.manip.axis_detent_ranges[-1].end = detent[1]
                        ob.xplane.manip.axis_detent_ranges[-1].height = detent[2]


        # end while for searching remaining blocks
        # TODO: Unit test, and what about a bunch of animations that get optimized out with not TRIS blocks?
        # Put this later
        if not bpy.data.objects:
            logger.warn(".obj had no real datablocks to create")
            return {"CANCELLED"}

        bpy.context.scene.frame_set(1)
        return {"FINISHED"}

    @property
    def _top_animation(self) -> Optional[IntermediateAnimation]:
        try:
            return self._anim_intermediate_stack[-1].animation
        except IndexError:
            return None

    @_top_animation.setter
    def _top_animation(self, value: IntermediateAnimation) -> None:
        self._anim_intermediate_stack[-1].animation = value

    @property
    def _top_intermediate_datablock(self) -> Optional[IntermediateDatablock]:
        try:
            return self._anim_intermediate_stack[-1].intermediate_datablock
        except IndexError:
            return None

    @_top_intermediate_datablock.setter
    def _top_intermediate_datablock(self, value: IntermediateDatablock) -> None:
        self._anim_intermediate_stack[-1].intermediate_datablock = value

    @property
    def _top_dataref(self) -> Optional[IntermediateDataref]:
        return self._top_animation.xp_dataref

    @_top_dataref.setter
    def _top_dataref(self, value: IntermediateDataref) -> None:
        self._top_animation.xp_dataref = value

    def _next_empty_name(self) -> str:
        return (
            f"ImpEmpty."
            f"{sum(1 for block in self._blocks if block.datablock_type == 'EMPTY'):03}"
            f"_{hex(hash(self.parent_collection.name))[2:6]}"
            f"_{random.randint(0,100000)}"
        )

    def _next_object_name(self) -> str:
        return (
            f"ImpMesh."
            f"{sum(1 for block in self._blocks if block.datablock_type == 'MESH'):03}"
            f"_{hex(hash(self.parent_collection.name))[2:6]}"
            f"_{random.randint(0,100000)}"
        )
